https://0.30000000000000004.com/#emacs-lisp



问题的根本在于计算机底层记录数据是二进制形式

在有限的记位限制中（Number使用64位双精度记录），无法精确表示0.1

> 如何求0.1对应而二进制表示
>
> ​	 连续*2取个位（非0即记位1）

IEEE 754

![image-20200525230400613](http://picbed.sedationh.cn/image-20200525230400613.png)

**0.1 + 0.1 为什么等于0.2**

答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。

又如，对于 0.1 + 0.3 ，结果其实并不是0.4，但0.4是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为0.4了，而不展示一个浮点数的真实结果了。

另外要注意，**二进制能精确地表示位数有限且分母是2的倍数的小数**，比如0.5，0.5在计算机内部就没有舍入误差。所以0.5 + 0.5 === 1

