曾经自己写过一遍

参考小册手写系列

尽量使用新特性

## call apply bind

### apply bind

两者都是用来改变指向并且调用的，只是参数有些不同

```js
Function.prototype.myCall = function (obj, ...args) {
  obj = obj || globalThis
  obj.fn = this
  const res = obj.fn(...args)
  delete obj.fn
  return res
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

getName()
getName.call(foo, 1, 2)
getName.myCall(foo, 1, 2)

```



```js
Function.prototype.myApply = function (obj, args) {
  obj = obj || globalThis
  obj.fn = this
  const res = obj.fn(...args)
  delete obj.fn
  return res
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

getName()
getName.apply(foo, [1, 2])
getName.myApply(foo, [1, 2])
```



### bind

### 能够用返回this调整后的函数

还可以用来make a function with pre-specified initial arguments.



```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  return (...insideArgs) => {
    this.call(obj, ...[...args, ...insideArgs])
  }
}
```

#### 但是之类没有解决 new 的问题

> The value to be passed as the `this` parameter to the target function `func` when the bound function is called. The value is ignored if the bound function is constructed using the [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) operator. When using `bind` to create a function (supplied as a callback) inside a `setTimeout`, any primitive value passed as `thisArg` is converted to object. If no arguments are provided to `bind `, or if the `thisArg` is `null` or `undefined`, the `this` of the executing scope is treated as the `thisArg` for the new function.

```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  return (...insideArgs) => {
    this.call(obj, ...[...args, ...insideArgs])
  }
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

function myNew(constructor, ...args) {
  const obj = {}
  const res = constructor.call(obj, ...args)
  Reflect.setPrototypeOf(obj, constructor.prototype)
  return res instanceof Object ? res : obj
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

const f1 = new (Foo.bind(foo, 'f1'))(1)
// const f2 = myNew(Foo.bind(foo, 'f2'), 2)

console.log(f1, foo)
// console.log(f2)

const f = Foo.bind(foo, 'f2')
console.dir(f)
```

还没处理好，问题出现在对bound function(BF) 的理解上

> The `bind()` function creates a new **bound function**, which is an *exotic function object* (a term from ECMAScript 2015) that wraps the original function object. Calling the bound function generally results in the execution of its wrapped function.
>
> When a bound function is called, it calls internal method `[[Call]]` on`[[BoundTargetFunction]]`, with following arguments `Call(boundThis, ...args)`. Where `boundThis` is `[[BoundThis]]`, `args` is `[[BoundArguments]]`, followed by the arguments passed by the function call.

#### f是个函数，是BF，从测试来看没有prototype

```js
Function.prototype.myBind = (obj, ...args) => {
  obj = obj || globalThis
  const self = this

  return function BF(...insideArgs) {
    console.log(this)
  }
}

const foo = {
  name: 'foo',
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

const BF1 = Foo.myBind(foo, 'BF1')

// BF1(1)

const BF2 = new (Foo.myBind(foo, 'BF2'))(2)

// 区别的关键点在于返回的FB是用什么方式进行调用的
// BF1: 正常调用BF 情况
//          BF的this指向的是window
// BF2: new的方式调用BF 情况
//          BF的this指向的是new所要创建的实例对象
```



#### 理解并解决

```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  const initialFunction = this

  return function BF(...insideArgs) {
    const isNewOperation = this !== globalThis
    const allArgs = [...args, ...insideArgs]
    return isNewOperation
      ? initialFunction.apply(this, allArgs)
      : initialFunction.apply(obj, allArgs)
  }
}

const foo = {
  name: 'foo',
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

const BF1 = Foo.myBind(foo, 'BF1')

BF1(1)

const BF2 = new (Foo.myBind(foo, 'BF2'))(2)
console.log(BF2)

console.log(foo)
```

还有个小问题

#### 没有处理好对于prototype的绑定

![image-20210315102355591](http://picbed.sedationh.cn/image-20210315102355591.png)

但正常的应该是有处理的

![image-20210315102559107](http://picbed.sedationh.cn/image-20210315102559107.png)

![image-20210315102923015](http://picbed.sedationh.cn/image-20210315102923015.png)

#### 处理prototype

```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  const initialFunction = this

  function BF(...insideArgs) {
    const isNewOperation = this !== globalThis
    const allArgs = [...args, ...insideArgs]
    return isNewOperation
      ? initialFunction.apply(this, allArgs)
      : initialFunction.apply(obj, allArgs)
  }

  BF.prototype = initialFunction.prototype
  return BF
}

const foo = {
  name: 'foo',
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

const BF1 = Foo.myBind(foo, 'BF1')
console.dir(BF1)
const BF11 = Foo.bind(foo, 'BF11')
console.dir(BF11)

// BF1(1)

const BF2 = new (Foo.myBind(foo, 'BF2'))(2)
console.log(BF2)

// console.log(foo)

const BF22 = new (Foo.bind(foo, 'BF22'))(22)
console.log(BF22)
```



#### 实现了一样的效果 

> Q:  是否存在Metaprogramming 可以搞出这样的 bound Foo

![image-20210315103241161](http://picbed.sedationh.cn/image-20210315103241161.png)

#### [绑定函数的名称](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name#绑定函数的名称)

[`Function.bind()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) 所创建的函数将会在函数的名称前加上"bound " 。

```
function foo() {};
foo.bind({}).name; // "bound foo"
```

#### 两次bind

啊 我以为我已经对了

可是两次bind 的验证结果不对

进行测试

```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  const initialFunction = this

  function BF(...insideArgs) {
    const isNewOperation = this instanceof initialFunction
    const allArgs = [...args, ...insideArgs]
    return isNewOperation
      ? initialFunction.apply(this, allArgs)
      : initialFunction.apply(obj, allArgs)
  }

  BF.prototype = initialFunction.prototype
  return BF
}

Function.prototype.bind2 = function (context) {
  if (typeof this !== 'function') {
    throw new Error(
      'Function.prototype.bind - what is trying to be bound is not callable'
    )
  }

  var self = this
  var bindArgs = Array.prototype.slice.call(arguments, 1)
  var fNOP = function () {}

  var fbound = function () {
    var args = bindArgs.concat(
      Array.prototype.slice.call(arguments)
    )
    self.apply(this instanceof self ? this : context, args)
  }

  fNOP.prototype = this.prototype
  fbound.prototype = new fNOP()

  return fbound
}

const foo = {
  name: 'foo',
}

const foo2 = {
  name: 'foo2',
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

// const BF1 = Foo.bind(foo, 'change a').bind(foo2, 'change b')
const BF1 = Foo.myBind(foo, 'change 1').myBind(
  foo2,
  'change 2'
)
// const BF1 = Foo.bind2(foo, 'change a').bind2(
//   foo2,
//   'change b'
// )

console.dir(BF1)
BF1()

console.log(foo, foo2)
```

#### 定位到问题 是 isNewOperation 的判断

new内部

```js
function myNew(Con, ...arg) {
  // Con 是构造函数
  const obj = {}
  // 将构造函数的prototype绑定到创建的对象上
  Object.setPrototypeOf(obj, Con.prototype)
  // 使用构造函数初始化对象
  const result = Con.apply(obj, arg)
  // 经测试，如果构造函数的返回值如果是对象，就会返回构造函数中指定的返回值
  return result instanceof Object ? result : obj
}
```

#### 关键语句

`Object.setPrototypeOf(obj, Con.prototype)`

`const isNewOperation = this instanceof initialFunction`

所以说，对于什么时候是new的情况，可以查看函数调用时候的this

问题解决～



容易产生迷惑的点在于多次的bind是如何执行的。一层套一层，最终是在里面执行的

开始嵌套 -> -> -> 

最终执行 <- <- <-



## new

过去写new没注意setPortotype的位置，待与其他调用进行交互的时候发现了问题

```js
function myNew(Con, ...args) {
  const obj = {}
  Reflect.setPrototypeOf(obj, Con.prototype)
  const res = Con.apply(obj, args)
  return res instanceof Object ? res : obj
}

Function.prototype.myBind = function (context, ...args) {
  context = context || globalThis
  const initialFunction = this

  function BF(...insideArgs) {
    const allArgs = [...args, ...insideArgs]
		// new.traget...也能用
    const isNewOperation = this instanceof BF
    initialFunction.apply(
      isNewOperation ? this : context,
      allArgs
    )
  }

  // 不知是否要公用？
  BF.prototype = initialFunction.prototype
  // 或者利用原型继承的方式再搞一个

  return BF
}

const foo = {
  name: 'foo',
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

Foo.prototype.getName = function () {
  return this.name
}

const f1 = new (Foo.myBind(foo, 'c 1'))(2)
console.log(f1)

const BF1 = new (Foo.bind(foo, 'foo1'))(1)
console.log(BF1.getName())
```



## instanceof

```js
function myInstanceOf(left, right) {
  let leftPrototype = Reflect.getPrototypeOf(left)
  const rightPrototype = right.prototype
  while (leftPrototype !== null) {
    if (leftPrototype === rightPrototype) {
      return true
    } else {
      leftPrototype = Reflect.getPrototypeOf(leftPrototype)
    }
  }
  return false
}

function Foo(name) {
  this.name = name
}

function Bar(age) {
  this.age = age
}

const f1 = new Foo('f1')

console.log(
  f1 instanceof Foo,
  f1 instanceof Bar,
  myInstanceOf(f1, Foo),
  myInstanceOf(f1, Bar),
  myInstanceOf(f1, Object)
)
```



## debounce throttle

https://segmentfault.com/a/1190000023127030

```js
function debounce(func, delay) {
  let timer

  return function (...args) {
    clearTimeout(timer)

    timer = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}

const body = document.querySelector('body')

const color = ['pink', 'black', 'green']
let i = 0
function changeBodyBackgroundColor() {
  if (i >= color.length) {
    i = 0
  }
  body.style.backgroundColor = color[i]
  i++
}

function throttle(func, threshold) {
  let last
  let timer

  threshold || (threshold = 250)

  return function (...args) {
    const now = +new Date()

    // 如果还在threshold过程中
    // if (last && last + threshold < now) {
    if (last && now - last < threshold) {
      clearTimeout(timer)

      timer = setTimeout(() => {
        last = now
        func.apply(this, args)
      }, threshold)
    } else {
      // 更改上次记录的时间
      last = now
      func.apply(this, args)
    }
  }
}

// window.addEventListener(
//   'scroll',
//   debounce(changeBodyBackgroundColor, 100)
// )
// window.addEventListener('scroll', changeBodyBackgroundColor)

window.addEventListener(
  'scroll',
  throttle(changeBodyBackgroundColor, 100)
)

```



https://www.sitepoint.com/throttle-scroll-events/ 其中提到了一点

> What I find interesting from looking at the source code is that `throttle()` is just a wrapper around `debounce()`. Throttling just passes a different set of parameters to change the desired behavior. Throttle sets a `maxWait` that guarantees the execution once it waits that long. The rest of the implementation remains the same.