## 00

### js的类型判断有哪些

谈有哪些类型

谈方法

谈内部逻辑

- typeof
- instanceof
- Object.prototype.toString



### 箭头函数

不是一个语法糖，经历过各种_this that ... 的懂得都懂～

使用所在上下文的this

没有prototype

```js
const Foo = () => {}
const f = new Foo()
text.html:3 Uncaught TypeError: Foo is not a constructor
    at text.html:3
```



联系new聊一聊～

使用new后拿到了啥？

返回了个对象，对象是用提供的构造函数初始化的，对象的原型指向构造函数的prototype，可以使用上面的共享方法～



### 介绍一下函数的作用，纯函数是什么，函数的副作用是什么

对一系列代码的封装

函数式编程的前提是，函数可以

1. 作为函数参数
2. 赋值给变量
3. 函数返回值



纯函数

1. 相同的输入永远有相同的输出，对外部状态无依赖
2. 没有副作用
   1. 对全局和入参的修改(引用)



好处

方便测试

纯函数可以进行稳定的组合，从而形成功能更强大的函数

没有数据共享，不存在并行处理下的race conditionw问题(web worker~)



再提一嘴柯里化curry

就参数缓存+延迟执行

```html
<script>
  function curry(fn) {
    return function curriedFn(...args) {
      if (args.length >= fn.length) {
        fn.call(this, ...args)
      } else {
        return function (...innerArgs) {
          return curriedFn(...args.concat(innerArgs))
        }
      }
    }
  }

  function add(a, b, c) {
    console.log(a + b + c)
  }
  const curriedAdd = curry(add)
  curriedAdd(1, 2)(3)
  curriedAdd(1)(2)(3)
</script>

<script>
  function curry(fn, ...args) {
    if (fn.length <= args.length) {
      fn(...args)
    } else {
      return function (..._args) {
        return curry(fn, ...args, ..._args)
      }
    }
  }
  function add(a, b, c) {
    console.log(a + b + c)
  }
  const curriedAdd = curry(add)
  curriedAdd(1, 2, 3)
  curriedAdd(1, 2)(3)
  curriedAdd(1)(2)(3)
</script>

```

如果不考虑this

```html
<script>
  const curry = (fn, ...args) =>
    fn.length <= args.length
      ? fn(...args)
      : (..._args) => curry(fn, ...args, ..._args)
  function add(a, b, c) {
    console.log(a + b + c)
  }
  const curriedAdd = curry(add)
  curriedAdd(1, 2, 3)
  curriedAdd(1, 2)(3)
  curriedAdd(1)(2)(3)
</script>
```



### 类数组转换为数组的几种方法

啥是类数组？

拥有length属性和若干索引的对象

但 arrayLike instanceof Array  === false 不一定有遍历、push等方法

arguments

- Array.from
  - The `Array.from()` static method creates a new, shallow-copied `Array` instance from an array-like or iterable object.
- slice
- [... arrayLike] 要求实现iterator接口



### bind

注意两个问题

- 多次bind第一次有效是为啥
- new的适配

```html
<script>
  var name = 'window'
  const obj = {
    name: 'obj',
  }
  function getName(a, b, c) {
    console.log(arguments)
    console.log(this.name)
  }
  // console.dir(getName.bind(obj, 1, 2, 3))
  Function.prototype.myBind = function (context, ...args) {
    context = context || globalThis /// 怎么拿到执行fn.myBind的上下文？
    const initialFn = this
    return function BF(..._args) {
      const isNewOperation = this instanceof BF
      return initialFn.apply(isNewOperation ? this : context, [
        ...args,
        ..._args,
      ])
    }
  }
  const bindedGetName = getName.myBind(obj, 1, 2)
  console.log(new bindedGetName())
  // getName.myBind(obj, 1, 2, 3)()
</script>
```



## 介绍一下Promise

红宝书第四版 期约

三个状态

- pending
- fulfilled
- rejected

